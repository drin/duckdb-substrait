import os
import yaml
import re

from os import walk
from pathlib import Path

from string import Template


# ------------------------------
# Module Variables

script_dirpath = Path(__file__).resolve().parent
repo_rootdir   = script_dirpath.parent


template_bootstrap_customfns = Template('''
#include "custom_extensions/custom_extensions.hpp"

//! This class is auto-generated by scripts/generate_custom_functions.py
//! It depends on substrait/extensions yaml files
namespace duckdb {

  SubstraitCustomFunctions SubstraitCustomFunctions::InitializedForDuckDB() {
    SubstraitCustomFunctions registry_custom_fns;

$function_body

    return registry_custom_fns;
  }

} // namespace duckdb
''')

template_insert_fn_ext = Template(
    '    registry_custom_fns.InsertFunctionExtension('
    '"$fn_name", { $fn_sig }, "$ext_path"'
    ');\n'
)


def parse_function_data(functions, yaml_data, function_type):
    for function_data in yaml_data.get(function_type, []):
        function = {
            'name': function_data['name'],
            'impls_args': []
        }

        for implementation in function_data.get('impls', []):
            args = []
            for arg in implementation.get('args', []):
                arg_info = {'name': arg.get('name', ''), 'value': arg.get('value', '')}
                args.append(arg_info)

            function['impls_args'].append(args)

        functions.append(function)

    return functions


def parse_yaml(yaml_fpath):
    with open(yaml_fpath, 'r') as yaml_handle:
        yaml_data = yaml.safe_load(yaml_handle)

    parsed_yaml_fns = []
    parse_function_data(parsed_yaml_fns, yaml_data, 'scalar_functions'   )
    parse_function_data(parsed_yaml_fns, yaml_data, 'aggregate_functions')

    return parsed_yaml_fns


def GenerateCodeFromFunctionExtensions():
    inner_code = ''
    type_set   = set()

    custom_extension_folder = repo_rootdir / 'substrait' / 'function-extensions'

    # If the folder doesn't exist, exit early
    if not custom_extension_folder.is_dir():
        print(f'Extension folder could not be found: {custom_extension_folder}')
        return inner_code

    # We want a listing of files in `custom_extension_folder` (don't descend further)
    _, _, ext_fnames = next(custom_extension_folder.walk())

    for ext_fname in ext_fnames:
        if not ext_fname.endswith('.yaml'): continue

        parsed_functions = parse_yaml(custom_extension_folder / ext_fname)

        for parsed_fn in parsed_functions:
            for impls_args in parsed_fn['impls_args']:
                param_types = []

                for args in impls_args: 
                    type_value = re.sub(r'<[^>]*>', '', args['value'])
                    if not len(type_value): continue

                    type_set.add(type_value)
                    param_types.append(f'"{type_value}"')

                inner_code += template_insert_fn_ext.substitute(
                     fn_name=parsed_fn['name']
                    ,fn_sig=', '.join(param_types)
                    ,ext_path=ext_fname
                )

    print(type_set)
    return inner_code


def WriteGeneratedCode(srcgen_customfns):
    target_fpath   = repo_rootdir / 'src' / 'custom_extensions_generated.cpp'

    # Open the file in write mode
    with open(target_fpath.resolve(), 'w') as output_handle:
        output_handle.write(template_bootstrap_customfns.substitute(
            function_body=srcgen_customfns
        ))


if __name__ == '__main__':
    generated_src_code = GenerateCodeFromFunctionExtensions()
    WriteGeneratedCode(generated_src_code)
